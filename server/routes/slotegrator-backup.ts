import { Router, Request, Response } from 'express';
import * as slotegratorService from '../services/slotegrator';
import * as realMoneyService from '../services/slotegrator-real-money';
import { authMiddleware } from '../utils/auth';
import rateLimiter from '../services/helpers/rateLimiter';
import { storage } from '../storage';
import jwt from 'jsonwebtoken';
import fs from 'fs';

const router = Router();

// ============= GAME LAUNCH ENDPOINTS =============

// Oyun URL'i alma endpoint'i (GameModal i√ßin)
router.post('/game-url', async (req: Request, res: Response) => {
  try {
    const { uuid, mode = 'demo', device = 'desktop', language = 'tr', currency = 'TRY' } = req.body;
    
    if (!uuid) {
      return res.status(400).json({ 
        success: false, 
        message: 'uuid gereklidir' 
      });
    }

    // Oyuncu bilgileri olu≈ütur
    let playerId = `demo_player_${Date.now()}`;
    let playerName = 'Demo Player';
    
    if (mode === 'real') {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({
          success: false,
          message: 'Ger√ßek para oyunu i√ßin giri≈ü yapmalƒ±sƒ±nƒ±z'
        });
      }

      try {
        const token = authHeader.substring(7);
        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'cryptonbets-secret-key') as any;
        
        const user = await storage.getUser(decoded.id);
        if (!user || (user.balance || 0) <= 0) {
          return res.status(400).json({
            success: false,
            message: 'Yetersiz bakiye. L√ºtfen para yatƒ±rƒ±n.'
          });
        }
        
        playerId = `user_${decoded.id}`;
        playerName = decoded.username || `Player${decoded.id}`;
      } catch (jwtError) {
        return res.status(401).json({
          success: false,
          message: 'Ge√ßersiz token'
        });
      }
    }

    console.log('üéÆ Game URL isteƒüi:', {
      uuid: uuid.substring(0, 8) + '...',
      mode,
      device,
      language,
      currency,
      playerId,
      playerName
    });

    let sessionId: string | undefined;
    
    // Ger√ßek para modu i√ßin √∂nce session olu≈ütur
    if (mode === 'real') {
      console.log('üîÑ Ger√ßek para modu i√ßin session olu≈üturuluyor...');
      const sessionResult = await slotegratorService.createSession(
        uuid,
        parseInt(playerId),
        playerName,
        currency
      );
      
      if (sessionResult?.url) {
        sessionId = 'session_created';
        console.log('‚úÖ Session olu≈üturuldu');
      } else {
        console.log('‚ùå Session olu≈üturulamadƒ±, demo moduna ge√ßiliyor');
        mode = 'demo';
      }
    }

    // Real money gaming i√ßin yeni servis kullan
    if (mode === 'real') {
      result = await realMoneyService.initRealMoneyGame(
        game_uuid,
        user.id,
        user.username || 'Player',
        user.balance || 0,
        currency,
        language,
        device,
        ipAddress
      );
    } else {
      result = await realMoneyService.initDemoGame(
        game_uuid,
        language,
        device
      );
    }

    res.json(result);

  } catch (error: any) {
    console.error('‚ùå Game URL hatasƒ±:', error);
    
    // Production credentials needed for real money gaming
    if (req.body.mode === 'real' && (error.message?.includes('Forbidden') || error.message?.includes('403'))) {
      return res.status(200).json({ 
        success: false, 
        message: 'Ger√ßek para oyunlarƒ± i√ßin production Slotegrator credentials gerekli. Demo mod kullanƒ±labilir.',
        needsProductionCredentials: true,
        mode: 'demo_fallback'
      });
    }
    
    res.status(500).json({ 
      success: false, 
      message: `Oyun URL'i alƒ±namadƒ±: ${error.message}`
    });
  }
});

// Eski endpoint uyumluluƒüu i√ßin
router.post('/init-game', async (req: Request, res: Response) => {
  try {
    const { game_uuid } = req.body;
    const gameMode = req.body.mode || 'demo';
    const gameDevice = req.body.device || 'desktop'; 
    const gameLanguage = req.body.language || 'tr';
    const gameCurrency = req.body.currency || 'TRY';
    
    if (!game_uuid) {
      return res.status(400).json({ 
        success: false, 
        message: 'game_uuid gereklidir' 
      });
    }

    // Yeni formatla √ßaƒüƒ±r  
    const uuid = game_uuid;
    
    // Oyuncu ID'si olu≈ütur
    let playerId;
    let playerName = 'Demo Player';
    
    if (gameMode === 'real' && req.user) {
      playerId = `user_${(req.user as any).id}_${Date.now()}`;
      playerName = (req.user as any).username || 'Real Player';
    } else {
      playerId = `demo_player_${Date.now()}`;
    }

    // Generate session ID for real money games
    const sessionId = gameMode === 'real' ? `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` : undefined;

    const gameResult = await slotegratorService.initGame(
      uuid,
      playerId,
      playerName,
      gameCurrency,
      gameLanguage,
      `${req.protocol}://${req.get('host')}/games/return`,
      gameMode as 'real' | 'demo',
      req.ip || '127.0.0.1',
      gameDevice,
      sessionId
    );

    res.json(gameResult);

  } catch (error: any) {
    console.error('Oyun ba≈ülatma endpoint hatasƒ±:', error);
    res.status(500).json({ 
      success: false, 
      message: `Genel hata: ${error.message}` 
    });
  }
});

// Cache yenileme endpoint'i - 10,159 oyun i√ßin tam cache olu≈üturma
router.post('/refresh-cache', async (req: Request, res: Response) => {
  try {
    console.log('=== MANUEL CACHE YENƒ∞LEME BA≈ûLADI ===');
    console.log('10,159 oyun i√ßin tam cache olu≈üturuluyor...');
    
    // Cache olu≈üturma s√ºrecini ba≈ülat (arka planda)
    slotegratorService.refreshCache(true).then(() => {
      console.log('Cache yenileme tamamlandƒ±!');
    }).catch(error => {
      console.error('Cache yenileme hatasƒ±:', error);
    });
    
    res.json({ 
      success: true, 
      message: 'Cache yenileme ba≈ülatƒ±ldƒ±',
      expected: '10,159 oyun y√ºkleniyor...'
    });
  } catch (error) {
    console.error('Cache yenileme endpoint hatasƒ±:', error);
    res.status(500).json({ error: 'Cache yenileme ba≈üarƒ±sƒ±z' });
  }
});

// T√ºm oyunlarƒ± getir
router.get('/games', async (req: Request, res: Response) => {
  try {
    const page = req.query.page ? parseInt(req.query.page as string) : 1;
    const perPage = req.query.perPage ? parseInt(req.query.perPage as string) : 50;
    const forceRefresh = req.query.forceRefresh === 'true';
    
    console.log(`üé∞ Slots API ƒ∞steƒüi - Sayfa: ${page}, PerPage: ${perPage}`);
    
    // Cache'den oyunlarƒ± al
    let games = await slotegratorService.getCachedGames(forceRefresh);
    
    // Cache bo≈üsa dosyadan y√ºkle
    if (games.length === 0) {
      console.log('Memory cache bo≈ü, dosyadan y√ºkleniyor...');
      try {
        const fs = await import('fs');
        const path = await import('path');
        const cacheFilePath = path.resolve('.slotegrator-cache.json');
        
        if (fs.existsSync(cacheFilePath)) {
          const cacheContent = fs.readFileSync(cacheFilePath, 'utf8');
          const cacheData = JSON.parse(cacheContent);
          
          if (cacheData.games && cacheData.games.length > 0) {
            games = cacheData.games;
            console.log(`üìÅ Dosyadan ${games.length} oyun y√ºklendi!`);
          }
        }
      } catch (fileError) {
        console.error('Dosya okuma hatasƒ±:', fileError);
      }
    }
    
    console.log(`‚úÖ Toplam ${games.length} oyun hazƒ±r`);
    
    // Sayfalama
    const startIndex = (page - 1) * perPage;
    const paginatedGames = games.slice(startIndex, startIndex + perPage);
    
    const response = {
      items: paginatedGames,
      _meta: {
        totalCount: games.length,
        pageCount: Math.ceil(games.length / perPage),
        currentPage: page,
        perPage: perPage
      }
    };
    
    console.log(`üì§ Sayfa ${page}: ${paginatedGames.length} oyun g√∂nderiliyor`);
    res.json(response);
    
  } catch (error) {
    console.error('‚ùå Slots API Hatasƒ±:', error);
    res.status(500).json({ 
      error: 'Oyunlar y√ºklenirken hata olu≈ütu',
      items: [],
      _meta: { totalCount: 0, pageCount: 0, currentPage: 1, perPage: 50 }
    });
  }
});

// T√ºm oyunlarƒ± getir (rate limiter ile MAX sayfa)
router.get('/games/max', async (req: Request, res: Response) => {
  try {
    const startTime = Date.now();
    
    // Cache anahtarƒ±
    const cacheKey = `all_games_max`;
    
    // Memory Cache
    const memoryCache: Record<string, {data: any, timestamp: number}> = (global as any).maxGamesCache || {};
    (global as any).maxGamesCache = memoryCache;
    
    // Cache s√ºresi
    const CACHE_TTL = 60 * 60 * 1000; // 1 saat
    
    // Cache'den kontrol et
    if (memoryCache[cacheKey] && (Date.now() - memoryCache[cacheKey].timestamp) < CACHE_TTL) {
      console.log(`T√ºm oyunlar memory cache'den alƒ±ndƒ±!`);
      const responseTime = Date.now() - startTime;
      
      const cachedResponse = memoryCache[cacheKey].data;
      cachedResponse._meta.responseTime = responseTime;
      cachedResponse._meta.source = 'memory_cache';
      
      return res.json(cachedResponse);
    }
    
    // API'den maksimum sayƒ±da oyun y√ºkle (profesyonel rate limit y√∂netimi ile)
    console.log('T√ºm oyunlar API √ºzerinden getirilecek...');
    
    // Rate limiter durumunu g√∂ster
    console.log('Rate limiter durumu:', rateLimiter.getStatus());
    
    // Maksimum sayƒ±da oyun getir (100 sayfa, sayfa ba≈üƒ±na 100 oyun)
    const maxPages = 100;
    const maxPerPage = 100;
    
    console.log(`Maksimum ${maxPages} sayfa, sayfa ba≈üƒ±na ${maxPerPage} oyun i√ßin istek g√∂nderiliyor...`);
    
    // T√ºm oyunlarƒ± √ßek
    const allGames = await slotegratorService.getMultiplePages(maxPages, maxPerPage);
    
    const endTime = Date.now();
    const responseTime = endTime - startTime;
    
    // ƒ∞statistikleri hesapla
    const mobileGames = allGames.filter(game => game.is_mobile === 1).length;
    const desktopGames = allGames.filter(game => game.is_mobile === 0).length;
    
    // Benzersiz saƒülayƒ±cƒ±larƒ± hesapla
    const providers = Array.from(new Set(allGames.map(game => game.provider))).filter(Boolean).sort();
    
    // Oyun t√ºrlerini hesapla
    const gameTypes: Record<string, number> = {};
    allGames.forEach(game => {
      if (game.tags && game.tags.length > 0) {
        game.tags.forEach(tag => {
          if (tag.code) {
            gameTypes[tag.code] = (gameTypes[tag.code] || 0) + 1;
          }
        });
      } else if (game.type) {
        gameTypes[game.type] = (gameTypes[game.type] || 0) + 1;
      }
    });
    
    // ƒ∞lk sayfa i√ßin sonu√ßlarƒ± hazƒ±rla (performans i√ßin)
    const perPage = 100;
    const paginatedGames = allGames.slice(0, perPage);
    
    // √ñzet rapor
    console.log('=== T√úM OYUNLAR TOPLAMA √ñZET ===');
    console.log(`Toplam ${allGames.length} oyun ba≈üarƒ±yla √ßekildi.`);
    console.log(`Toplam ${providers.length} benzersiz saƒülayƒ±cƒ± bulundu.`);
    console.log(`Saƒülayƒ±cƒ±lar: ${providers.join(', ')}`);
    console.log(`Mobil oyunlar: ${mobileGames}, Masa√ºst√º oyunlar: ${desktopGames}`);
    console.log(`Y√ºkleme s√ºresi: ${responseTime}ms`);
    
    // Yanƒ±t hazƒ±rla
    const response = {
      items: paginatedGames,
      _meta: {
        totalCount: allGames.length,
        pageCount: Math.ceil(allGames.length / perPage),
        currentPage: 1,
        perPage,
        responseTime,
        providerCount: providers.length,
        providers,
        mobileGames,
        desktopGames,
        gameTypes
      },
      allGames: allGames // T√ºm oyunlarƒ± da g√∂nder
    };
    
    // Memory cache'e kaydet
    memoryCache[cacheKey] = {
      data: response,
      timestamp: Date.now()
    };
    
    // Yanƒ±t d√∂n
    return res.json(response);
  } catch (error) {
    console.error('Error in /games/max endpoint:', error);
    res.status(500).json({ error: 'Failed to fetch all games', details: String(error) });
  }
});

// HIZLI Slot oyunlarƒ± - Direct API yakla≈üƒ±mƒ±
router.get('/games/slots', async (req: Request, res: Response) => {
  try {
    const startTime = Date.now();
    
    // Query parametreleri
    const pageNum = Math.max(1, parseInt(String(req.query.page || '1')) || 1);
    const requestedPerPage = parseInt(String(req.query.perPage || '50')) || 50;
    const perPageNum = requestedPerPage >= 1000 ? Number.MAX_SAFE_INTEGER : Math.max(1, Math.min(500, requestedPerPage));
    const providerFilter = req.query.provider as string | undefined;
    const mobileFilter = req.query.mobile === '1';
    
    console.log(`‚ö° HIZLI Slot API - Direct yakla≈üƒ±m`);
    
    // HIZLI √á√ñZ√úM: Cache varsa kullan, yoksa hƒ±zlƒ± direct API
    let allGames: any[] = [];
    
    try {
      // √ñnce cache'e hƒ±zlƒ± bak (timeout olmadan)
      allGames = await slotegratorService.getCachedGames(false);
      
      if (allGames.length === 0) {
        console.log(`Cache hen√ºz hazƒ±r deƒüil, API'den y√ºkleniyor...`);
        return res.status(202).json({ 
          message: 'Oyunlar y√ºkleniyor, l√ºtfen birka√ß saniye bekleyin',
          loading: true,
          _meta: {
            totalCount: 0,
            currentPage: pageNum,
            perPage: perPageNum,
            responseTime: Date.now() - startTime
          }
        });
      } else {
        console.log(`Cache'den ${allGames.length} oyun alƒ±ndƒ±`);
      }
    } catch (error) {
      console.error('Cache y√ºkleme hatasƒ±:', error);
      return res.status(503).json({ 
        error: 'Slot oyunlarƒ± y√ºklenemedi. L√ºtfen birka√ß dakika sonra tekrar deneyin.',
        _meta: {
          responseTime: Date.now() - startTime
        }
      });
    }
    
    // MAKSIMUM SLOT OYUNU DAHƒ∞L ETME - Sadece kesin live casino masasƒ± oyunlarƒ±nƒ± hari√ß tut
    let games = allGames.filter(game => {
      const gameType = (game.type || '').toLowerCase();
      const gameName = (game.name || '').toLowerCase();
      const provider = (game.provider || '').toLowerCase();
      
      // Sadece 100% kesin live casino masasƒ± oyunlarƒ±nƒ± hari√ß tut
      const absoluteExcludeTypes = ['roulette', 'blackjack', 'baccarat'];
      const excludeProviders = ['evolution gaming', 'ezugi'];
      
      // Live casino saƒülayƒ±cƒ±larƒ±nƒ± hari√ß tut
      if (excludeProviders.includes(provider)) {
        return false;
      }
      
      // Sadece kesin masa oyunlarƒ±nƒ± hari√ß tut
      if (absoluteExcludeTypes.includes(gameType)) {
        return false;
      }
      
      // GERƒ∞ KALAN HER ≈ûEYƒ∞ SLOT OLARAK KABUL ET
      // Slots, Table games, Casual, Lottery, Instant Win, Crash, Fishing vb.
      return true;
    });
    
    console.log(`üé∞ MAKSIMUM SLOT Fƒ∞LTRELEME: ${allGames.length} oyundan ${games.length} slot oyunu hazƒ±rlandƒ±`);
    
    // Debug: Ger√ßekte ka√ß oyun d√∂n√ºyor
    console.log(`Filtreleme √∂ncesi: ${games.length} oyun`);
    
    // T√ºm oyunlarƒ± slot olarak d√∂nd√ºr - maximum dahil etme
    
    // Eƒüer hi√ß slot oyunu yoksa hata d√∂nd√ºr
    if (games.length === 0) {
      return res.status(503).json({ 
        error: 'Cache hen√ºz hazƒ±rlanƒ±yor',
        message: 'Oyunlar y√ºkleniyor, l√ºtfen birka√ß saniye bekleyin',
        _meta: {
          totalCount: 0,
          pageCount: 0,
          currentPage: pageNum,
          perPage: perPageNum,
          responseTime: Date.now() - startTime,
          source: 'loading'
        }
      });
    }
    
    // Ek filtreler uygula
    let filteredGames = games;
    
    if (providerFilter) {
      filteredGames = filteredGames.filter(game => game.provider === providerFilter);
    }
    
    if (mobileFilter !== undefined) {
      filteredGames = filteredGames.filter(game => game.is_mobile === (mobileFilter ? 1 : 0));
    }
    
    // Sayfalama
    const startIndex = (pageNum - 1) * perPageNum;
    const paginatedGames = filteredGames.slice(startIndex, startIndex + perPageNum);
    
    const endTime = Date.now();
    const responseTime = endTime - startTime;
    console.log(`‚úÖ Slot oyunlarƒ± hazƒ±rlandƒ±: ${paginatedGames.length}/${filteredGames.length} - ${responseTime}ms`);
    
    // Yanƒ±t hazƒ±rla
    const response = {
      items: paginatedGames,
      _meta: {
        totalCount: filteredGames.length,
        pageCount: Math.ceil(filteredGames.length / perPageNum),
        currentPage: pageNum,
        perPage: perPageNum,
        responseTime,
        source: 'cached_filtered'
      }
    };
    
    res.json(response);
  } catch (error) {
    console.error('Error in /games/slots endpoint:', error);
    res.status(500).json({ error: 'Failed to fetch slot games' });
  }
});

// Casino oyunlarƒ±nƒ± getir (geli≈ümi≈ü filtreleme ve cache)
router.get('/games/casino', async (req: Request, res: Response) => {
  try {
    // Yanƒ±t zamanƒ±nƒ± √∂l√ß
    const startTime = Date.now();
    
    // Memory cache anahtarƒ±
    const cacheKey = `casino_${JSON.stringify(req.query)}`;
    
    // Memory Cache (Route Handler seviyesinde)
    const memoryCache: Record<string, {data: any, timestamp: number}> = (global as any).slotegratorMemoryCache || {};
    (global as any).slotegratorMemoryCache = memoryCache;
    
    // Cache s√ºresi (5 dakika)
    const CACHE_TTL = 5 * 60 * 1000;
    
    // √ñnce memory cache'den kontrol et
    if (memoryCache[cacheKey] && (Date.now() - memoryCache[cacheKey].timestamp) < CACHE_TTL) {
      console.log(`Casino oyunlarƒ± memory √∂nbellekten alƒ±ndƒ±! (${cacheKey})`);
      const responseTime = Date.now() - startTime;
      
      // Response meta data'ya performans bilgisini ekle
      const cachedResponse = memoryCache[cacheKey].data;
      cachedResponse._meta.responseTime = responseTime;
      cachedResponse._meta.source = 'memory_cache';
      
      return res.json(cachedResponse);
    }
    
    // Memory cache'de yoksa veritabanƒ± cache'ine bak
    const cachedCasinoGames = await slotegratorService.getCachedCasinoGames();
    let games;
    
    if (cachedCasinoGames && cachedCasinoGames.length > 0) {
      console.log('Casino oyunlarƒ± DB √∂nbellekten getirildi!');
      games = cachedCasinoGames;
    } else {
      console.log('Casino oyunlarƒ± API √ºzerinden getirilecek...');
      try {
        games = await slotegratorService.getCasinoGames();
        // Verileri √∂nbelleƒüe kaydet
        if (games && games.length > 0) {
          await slotegratorService.cacheCasinoGames(games);
        }
      } catch (error) {
        console.error('Casino oyunlarƒ± API hatasƒ±:', error);
        // API ba≈üarƒ±sƒ±z olursa bo≈ü liste d√∂nd√ºr
        games = [];
      }
    }
    
    // Query parametreleri
    const page = req.query.page ? parseInt(req.query.page as string) : 1;
    const perPage = req.query.perPage ? parseInt(req.query.perPage as string) : 50;
    const provider = req.query.provider as string | undefined;
    const mobile = req.query.mobile !== undefined ? req.query.mobile === '1' : undefined;
    const gameType = req.query.gameType as string | undefined;
    const useCache = req.query.useCache !== 'false'; // Varsayƒ±lan olarak cache kullan
    
    // Filtrelemeleri tek ge√ßi≈üte yap (performans i√ßin)
    games = games.filter(game => {
      // Provider filtrelemesi
      if (provider && game.provider !== provider) {
        return false;
      }
      
      // Mobil/masa√ºst√º filtrelemesi
      if (mobile !== undefined && game.is_mobile !== (mobile ? 1 : 0)) {
        return false;
      }
      
      // Oyun tipi filtrelemesi
      if (gameType && gameType !== 'all') {
        // Etiketlerde oyun t√ºr√º kontrol√º
        if (!game.tags || !game.tags.some(tag => tag.code.toLowerCase() === gameType.toLowerCase())) {
          return false;
        }
      }
      
      return true;
    });
    
    // Toplam sonu√ß
    const totalCount = games.length;
    
    // Sayfalama
    const startIndex = (page - 1) * perPage;
    const paginatedGames = games.slice(startIndex, startIndex + perPage);
    
    const endTime = Date.now();
    const responseTime = endTime - startTime;
    console.log(`Casino oyunlarƒ± yanƒ±t s√ºresi: ${responseTime}ms, toplam ${totalCount} oyun`);
    
    // Yanƒ±t hazƒ±rla
    const response = {
      items: paginatedGames,
      _meta: {
        totalCount,
        pageCount: Math.ceil(totalCount / perPage),
        currentPage: page,
        perPage,
        responseTime,
        source: 'db_cache'
      }
    };
    
    // Memory cache'e kaydet (sonraki hƒ±zlƒ± eri≈üimler i√ßin)
    if (useCache) {
      memoryCache[cacheKey] = {
        data: response,
        timestamp: Date.now()
      };
    }
    
    // Yanƒ±t d√∂n
    res.json(response);
  } catch (error) {
    console.error('Error in /games/casino endpoint:', error);
    res.status(500).json({ error: 'Failed to fetch casino games' });
  }
});

// Saƒülayƒ±cƒ±larƒ± getir
router.get('/providers', async (req: Request, res: Response) => {
  try {
    const forceRefresh = req.query.forceRefresh === 'true';
    // Daha doƒüru bir isteƒüe g√∂re saƒülayƒ±cƒ±larƒ± al
    const providers = await slotegratorService.getAllProviders(forceRefresh);
    
    // Mobil uyumlu saƒülayƒ±cƒ±larƒ± bulmak i√ßin parametre 
    const mobileOnly = req.query.mobile === 'true';
    
    if (mobileOnly) {
      // Mobil uyumlu oyunlarƒ± olan saƒülayƒ±cƒ±larƒ± filtrele
      const mobileGames = await slotegratorService.getMobileGames();
      const mobileProviders = new Set(mobileGames.map(game => game.provider));
      res.json({ items: providers.filter(provider => mobileProviders.has(provider)) });
    } else {
      res.json({ items: providers });
    }
  } catch (error) {
    console.error('Error in /providers endpoint:', error);
    res.status(500).json({ error: 'Failed to fetch providers' });
  }
});

// Saƒülayƒ±cƒ±larƒ± analiz et ve √∂nbellek durumunu kontrol et
router.get('/providers/analyze', async (req: Request, res: Response) => {
  try {
    // T√ºm saƒülayƒ±cƒ±larƒ± getir
    const providers = await slotegratorService.getAllProviders();
    
    // √ñnbellek durumunu kontrol et
    const cacheStatus: Record<string, any> = {};
    
    // Toplam oyun sayƒ±sƒ±
    const allGames = await slotegratorService.getCachedGames();
    
    // Mobil oyunlarƒ± getir
    const mobileGames = allGames.filter(game => game.is_mobile === 1);
    
    // Oyun t√ºrlerini analiz et
    const gameTypes: Record<string, number> = {};
    allGames.forEach(game => {
      if (game.tags && game.tags.length > 0) {
        game.tags.forEach(tag => {
          if (tag.code) {
            gameTypes[tag.code] = (gameTypes[tag.code] || 0) + 1;
          }
        });
      } else if (game.type) {
        gameTypes[game.type] = (gameTypes[game.type] || 0) + 1;
      }
    });
    
    // Saƒülayƒ±cƒ± analizi
    for (const provider of providers) {
      const providerGames = allGames.filter(game => game.provider === provider);
      const mobilePlatformGames = providerGames.filter(game => game.is_mobile === 1);
      
      cacheStatus[provider] = {
        gameCount: providerGames.length,
        mobileGameCount: mobilePlatformGames.length,
        desktopGameCount: providerGames.length - mobilePlatformGames.length,
      };
    }
    
    res.json({
      totalGames: allGames.length,
      totalProviders: providers.length,
      providers: providers,
      providerAnalysis: cacheStatus,
      mobileGames: mobileGames.length,
      desktopGames: allGames.length - mobileGames.length,
      gameTypes: gameTypes
    });
  } catch (error) {
    console.error('Error in /providers/analyze endpoint:', error);
    res.status(500).json({ error: 'Failed to analyze providers' });
  }
});

// Belirli bir saƒülayƒ±cƒ± i√ßin oyunlarƒ± y√ºkle
router.get('/providers/fetch/:provider', async (req: Request, res: Response) => {
  try {
    const provider = req.params.provider;
    if (!provider) {
      return res.status(400).json({ error: 'Provider adƒ± belirtilmedi' });
    }
    
    console.log(`"${provider}" saƒülayƒ±cƒ±sƒ± i√ßin oyunlar y√ºkleniyor...`);
    
    // Belirli bir saƒülayƒ±cƒ± i√ßin oyunlarƒ± √ßek
    const games = await slotegratorService.fetchGamesForProvider(provider);
    
    res.json({
      provider,
      totalGames: games.length,
      mobileGames: games.filter(game => game.is_mobile === 1).length,
      desktopGames: games.filter(game => game.is_mobile === 0).length,
      success: games.length > 0,
      message: games.length > 0 
        ? `${provider} saƒülayƒ±cƒ±sƒ± i√ßin ${games.length} oyun ba≈üarƒ±yla y√ºklendi.` 
        : `${provider} saƒülayƒ±cƒ±sƒ± i√ßin oyun bulunamadƒ±.`
    });
  } catch (error) {
    console.error(`Error fetching games for provider ${req.params.provider}:`, error);
    res.status(500).json({ 
      error: 'Failed to fetch games for provider',
      provider: req.params.provider,
      message: error instanceof Error ? error.message : 'Bilinmeyen hata'
    });
  }
});
router.get('/providers/fetch/:provider', async (req: Request, res: Response) => {
  try {
    const provider = req.params.provider;
    
    // ƒ∞steƒüi al ve i≈ülemi ba≈ülat
    res.status(202).json({ 
      status: 'processing', 
      provider, 
      message: `${provider} i√ßin oyunlar y√ºkleniyor...`,
      note: "Bu i≈ülem arka planda devam edecek ve tamamlandƒ±ƒüƒ±nda √∂nbellekte saklanacaktƒ±r."
    });
    
    // Arka planda saƒülayƒ±cƒ± i√ßin oyunlarƒ± y√ºklemeyi ba≈ülat
    slotegratorService.fetchGamesForProvider(provider)
      .then(games => {
        console.log(`${provider} i√ßin ${games.length} oyun ba≈üarƒ±yla y√ºklendi ve √∂nbelleƒüe alƒ±ndƒ±.`);
      })
      .catch(err => {
        console.error(`${provider} i√ßin oyun y√ºkleme hatasƒ±:`, err);
      });
      
  } catch (error) {
    console.error(`Error in /providers/fetch/${req.params.provider} endpoint:`, error);
    res.status(500).json({ error: 'Failed to fetch games for provider' });
  }
});

// Belirli bir saƒülayƒ±cƒ±nƒ±n oyunlarƒ±nƒ± getir
router.get('/games/provider/:provider', async (req: Request, res: Response) => {
  try {
    const provider = req.params.provider;
    const games = await slotegratorService.getGamesByProvider(provider);
    
    // Query parametreleri
    const page = req.query.page ? parseInt(req.query.page as string) : 1;
    const perPage = req.query.perPage ? parseInt(req.query.perPage as string) : 50;
    
    // Sayfalama uygula
    const startIndex = (page - 1) * perPage;
    const paginatedGames = games.slice(startIndex, startIndex + perPage);
    
    res.json({
      items: paginatedGames,
      _meta: {
        totalCount: games.length,
        pageCount: Math.ceil(games.length / perPage),
        currentPage: page,
        perPage: perPage
      }
    });
  } catch (error) {
    console.error(`Error in /games/provider/${req.params.provider} endpoint:`, error);
    res.status(500).json({ error: 'Failed to fetch provider games' });
  }
});

// Belirli bir oyunu getir
router.get('/games/:uuid', async (req: Request, res: Response) => {
  try {
    const uuid = req.params.uuid;
    const game = await slotegratorService.getGameByUuid(uuid);
    
    if (!game) {
      return res.status(404).json({ error: 'Game not found' });
    }
    
    res.json(game);
  } catch (error) {
    console.error(`Error in /games/${req.params.uuid} endpoint:`, error);
    res.status(500).json({ error: 'Failed to fetch game' });
  }
});

// Oyun ba≈ülatma (init) - Kullanƒ±cƒ± kimlik doƒürulamasƒ± gerekli
router.post('/games/init', authMiddleware, async (req: Request, res: Response) => {
  try {
    // Request body'den parametreleri al
    const { 
      game_uuid, 
      currency = 'USD', 
      language = 'tr', 
      return_url, 
      mode = 'real',
      device = 'desktop'
    } = req.body;
    
    // Gerekli parametreleri kontrol et
    if (!game_uuid) {
      return res.status(400).json({ error: 'game_uuid is required' });
    }
    
    if (!return_url) {
      return res.status(400).json({ error: 'return_url is required' });
    }
    
    // Kullanƒ±cƒ± bilgilerini al
    const user = req.user;
    
    if (!user) {
      return res.status(401).json({ error: 'User not authenticated' });
    }
    
    // Slotegrator i√ßin oyuncu ID olarak id kullanƒ±yoruz
    const playerId = String(user.id);
    
    // IP adresini al
    const ipAddress = req.ip || req.socket.remoteAddress || '127.0.0.1';
    
    // Ger√ßek para oyunu i√ßin kullanƒ±cƒ± bakiyesi kontrol√º
    let result;
    
    if (mode === 'real') {
      // Authenticated user i√ßin ger√ßek para oyunu
      result = await realMoneyService.initRealMoneyGame(
        game_uuid,
        user.id,
        user.username || 'Player',
        user.balance || 0,
        currency,
        language,
        device,
        ipAddress
      );
    } else {
      // Demo oyun
      result = await realMoneyService.initDemoGame(
        game_uuid,
        language,
        device
      );
    }
    
    res.json(result);
  } catch (error) {
    console.error('Error in /games/init endpoint:', error);
    res.status(500).json({ error: 'Failed to initialize game' });
  }
});

// Lobby verisi al - Kullanƒ±cƒ± kimlik doƒürulamasƒ± gerekli
router.post('/games/lobby', authMiddleware, async (req: Request, res: Response) => {
  try {
    // Request body'den parametreleri al
    const { 
      game_uuid, 
      currency = 'USD', 
      language = 'tr'
    } = req.body;
    
    // Gerekli parametreleri kontrol et
    if (!game_uuid) {
      return res.status(400).json({ error: 'game_uuid is required' });
    }
    
    // Kullanƒ±cƒ± bilgilerini al
    const user = req.user;
    
    if (!user) {
      return res.status(401).json({ error: 'User not authenticated' });
    }
    
    // Slotegrator i√ßin oyuncu ID olarak id kullanƒ±yoruz
    const playerId = String(user.id);
    
    // Lobby verisini getir
    const result = await slotegratorService.getGameLobby(
      game_uuid,
      playerId,
      currency,
      language
    );
    
    res.json(result);
  } catch (error) {
    console.error('Error in /games/lobby endpoint:', error);
    res.status(500).json({ error: 'Failed to get game lobby' });
  }
});

// Slotegrator Callback Endpoint - https://cryptonbets1.com/api/slotegrator/callback URL'i kullanƒ±lacak
router.post('/callback', async (req: Request, res: Response) => {
  try {
    console.log('Slotegrator callback received:', req.body);
    
    // Headers'da imza doƒürulama i≈ülemini ekle
    const merchantId = req.headers['x-merchant-id'];
    const timestamp = req.headers['x-timestamp'];
    const nonce = req.headers['x-nonce'];
    const signature = req.headers['x-sign'];
    
    // Gelen imzayƒ± kontrol et - ger√ßek uygulamada bu doƒürulama eklenmeli
    if (!merchantId || !timestamp || !nonce || !signature) {
      console.error('Missing required headers for callback validation');
      // Slotegrator callback i√ßin 200 d√∂nd√ºrmek daha iyi, ama hata loglanmalƒ±
      return res.status(200).json({ status: 'error', message: 'Missing headers' });
    }
    
    // Callback tipine g√∂re i≈ülem yapma
    const callbackType = req.body.type;
    console.log(`Handling callback type: ${callbackType}`);
    
    switch(callbackType) {
      case 'balance':
        // Bakiye sorgusu
        const userId = req.body.user_id;
        console.log(`Processing balance request for user: ${userId}`);
        
        try {
          // Ger√ßek uygulama: kullanƒ±cƒ± bakiyesini veritabanƒ±ndan sorgula
          // √ñrnek: const user = await storage.getUser(userId);
          // ≈ûu an i√ßin sabit bir deƒüer d√∂n√ºyoruz
          return res.json({
            balance: 1000.00
          });
        } catch (err) {
          console.error(`Error fetching user balance: ${err}`);
          return res.json({
            balance: 0.00
          });
        }
        
      case 'bet':
        // Bahis i≈ülemi
        const betAmount = req.body.amount;
        const betUserId = req.body.user_id;
        const transactionId = req.body.transaction_id;
        
        console.log(`Processing bet: User=${betUserId}, Amount=${betAmount}, Transaction=${transactionId}`);
        
        // Ger√ßek uygulama: bahis i≈ülemini kaydet ve kullanƒ±cƒ± bakiyesini g√ºncelle
        // √ñrnek: await storage.updateUserBalance(betUserId, -betAmount);
        
        return res.json({
          status: 'ok'
        });
        
      case 'win':
        // Kazan√ß i≈ülemi
        const winAmount = req.body.amount;
        const winUserId = req.body.user_id;
        const winTransactionId = req.body.transaction_id;
        
        console.log(`Processing win: User=${winUserId}, Amount=${winAmount}, Transaction=${winTransactionId}`);
        
        // Ger√ßek uygulama: kazan√ß i≈ülemini kaydet ve kullanƒ±cƒ± bakiyesini g√ºncelle
        // √ñrnek: await storage.updateUserBalance(winUserId, winAmount);
        
        return res.json({
          status: 'ok'
        });
        
      case 'rollback':
        // ƒ∞≈ülem geri alma
        const rollbackTransactionId = req.body.transaction_id;
        console.log(`Processing rollback for transaction: ${rollbackTransactionId}`);
        
        // Ger√ßek uygulama: ilgili i≈ülemi iptal et ve kullanƒ±cƒ± bakiyesini g√ºncelle
        
        return res.json({
          status: 'ok'
        });
        
      default:
        console.warn(`Unknown callback type received: ${callbackType}`);
        return res.status(200).json({ status: 'ok', message: 'Unknown type but acknowledged' });
    }
  } catch (error: any) {
    console.error('Error in Slotegrator callback endpoint:', error);
    // Slotegrator i√ßin hata durumunda da 200 d√∂nd√ºrmek daha iyi
    return res.status(200).json({ status: 'error', message: error.message });
  }
});

// Oyun URL'i alma endpoint'i - Session endpoint uyumlu  
router.post('/game-url', async (req: Request, res: Response) => {
  try {
    const { uuid, mode = 'demo', device = 'desktop', language = 'tr', currency = 'TRY' } = req.body;

    console.log('üéÆ Oyun URL alma isteƒüi:', {
      uuid: uuid?.substring(0, 12) + '...',
      mode,
      timestamp: new Date().toISOString()
    });

    if (!uuid) {
      console.error('‚ùå Oyun UUID eksik');
      return res.status(400).json({
        success: false,
        message: 'Oyun UUID\'si gerekli'
      });
    }

    // Kullanƒ±cƒ± bilgilerini al - ger√ßek para oyunlarƒ± i√ßin gerekli
    const user = (req as any).user;
    let userId: string | undefined;
    
    if (mode === 'real') {
      // Ger√ßek para oyunlarƒ± i√ßin kullanƒ±cƒ± kimlik doƒürulamasƒ± zorunlu
      if (!user || !user.id) {
        return res.status(401).json({
          success: false,
          message: 'Ger√ßek para oyunlarƒ± i√ßin giri≈ü yapmanƒ±z gerekli'
        });
      }
      userId = String(user.id);
    }
    
    console.log('üöÄ Slotegrator session olu≈üturuluyor...', {
      mode,
      currency: 'TRY',
      hasUser: !!userId,
      userId: userId ? userId.substring(0, 4) + '...' : 'yok'
    });
    
    // TRY para birimi ve T√ºrk√ße dil kullan
    const gameUrl = await slotegratorService.createSession(uuid, mode, 'TRY', 'tr', userId);
    
    if (!gameUrl) {
      throw new Error('Oyun URL\'si alƒ±namadƒ±');
    }

    console.log('‚úÖ Oyun URL\'si ba≈üarƒ±yla alƒ±ndƒ±:', {
      uuid: uuid.substring(0, 12) + '...',
      mode,
      urlLength: gameUrl.length,
      urlDomain: gameUrl.split('/')[2] || 'bilinmeyen'
    });

    res.json({
      success: true,
      url: gameUrl,
      mode,
      message: mode === 'real' ? 'Ger√ßek para oyunu ba≈ülatƒ±lƒ±yor' : 'Demo oyun ba≈ülatƒ±lƒ±yor'
    });

  } catch (error: any) {
    console.error('‚ùå Oyun URL alma hatasƒ±:', {
      error: error.message,
      stack: error.stack?.split('\n')[0],
      uuid: req.body?.uuid?.substring(0, 12) + '...' || 'bilinmeyen'
    });
    
    res.status(500).json({
      success: false,
      message: 'Oyun ba≈ülatƒ±lamadƒ±',
      details: error.message
    });
  }
});

export default router;